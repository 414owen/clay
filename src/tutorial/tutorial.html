<section id=tutorial name=tutorial>
  <div class="text one-col">
    <h3>Tutorial</h3>
    <p>
      Clay is an EDSL that uses a monad to collect style rules. Rules are
      combinations of CSS selectors with associated style properties. Multiple
      style rules can be composed and nested to form a stylehseet. Stylesheets
      can be rendered to plain old CSS and served to your browser.
    </p>

    <p>
      There are several methods of assigning style properties to selectors.
      The most important one is the <code>?</code> operator:
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/questionmark.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/questionmark.clay.hs.output.html -->
    </div>

    <p>
      Style rules can easily be composed and nested by just adding more rules
      using the monad syntax:
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/nesting.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/nesting.clay.hs.output.html -->
    </div>

    <p>
      Basic selectors can be composed with several combinators to construct
      more complicated selectors:
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/selectors.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/selectors.clay.hs.output.html -->
    </div>

    <p>
      Using <code>OverloadedStrings</code> allows us to create selectors for
      classes, ids, pseudo classes, attributes etc:
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/overloadedstrings.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/overloadedstrings.clay.hs.output.html -->
    </div>

    <p>
      Or we can use some build in functions to avoid to much string literals:
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/nostrings.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/nostrings.clay.hs.output.html -->
    </div>

    <p>
      Sometimes browsers implement exotic style properties or values that Clay
      doesn't yet know of. For most value type it is easy to supply a custom
      value using the <code>Other</code> type class. We can even escape from
      the type world entirely by using the fallback operator <code>-:</code>.
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/escape.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/escape.clay.hs.output.html -->
    </div>

    <p>
      Not every browser implements the full CSS standard and some browsers
      introduce experimental features that are not yet in the standard. Most
      experimental properties in Clay are automatically prefixed with vendor
      prefixes.
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/prefixes.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/prefixes.clay.hs.output.html -->
    </div>

    <p>
      Because Clay is just Haskell we can do some really nice tricks that might
      take a lot of effort in other CSS preprocessors. Functions, mixins,
      control structures, colors and size calculation, all is easy. The
      following (somewhat contrived) example shows how to use the
      expressiveness of Haskell to produce more advanced stylesheets:
    </p>
    <div class="code haskell">
      <!--#include virtual=../highlighted/advanced.clay.hs.html -->
    </div>
    <div class="code css">
      <!--#include virtual=../highlighted/advanced.clay.hs.output.html -->
    </div>

    <p>
      More examples comming soon!
    </p>

  </div>

</section>
